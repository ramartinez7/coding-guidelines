# Entity Identity Strategies (Choosing the Right Identity Pattern)

> Using auto-increment IDs or random GUIDs without considering domain needs leads to confusion and performance issues—choose identity strategies that match business requirements and technical constraints.

## Problem

Entities need unique identifiers, but there are multiple strategies for generating them. Using the wrong strategy can lead to distributed system conflicts, poor performance, or identifiers that don't align with business needs.

## Identity Strategy Options

### Strategy 1: Database Auto-Increment

```csharp
// ❌ Problems with auto-increment IDs
public class Order
{
    public int Id { get; set; }  // Auto-increment from database
    
    // Problem 1: Can't create ID before saving
    // Problem 2: Conflicts in distributed systems
    // Problem 3: Guessable, leaks information
}

// Must save to get ID
var order = new Order { CustomerId = customerId };
await _db.Orders.AddAsync(order);
await _db.SaveChangesAsync();  // Only now do we have order.Id

// Can't use order ID for anything until after save
```

### Strategy 2: Random GUID

```csharp
// ✅ Better: Client-generated GUID
public class Order
{
    public Guid Id { get; }  // Generated by application
    
    private Order(Guid id, CustomerId customerId)
    {
        Id = id;
        CustomerId = customerId;
    }
    
    public static Order Create(CustomerId customerId)
    {
        return new Order(Guid.NewGuid(), customerId);
    }
}

// Can create ID immediately
var order = Order.Create(customerId);
// Can use order.Id before saving
await SendMessageAsync(order.Id);  // ✓ Already have ID
await _db.Orders.AddAsync(order);
await _db.SaveChangesAsync();
```

### Strategy 3: Sequential GUID (Best for SQL Server)

```csharp
// ✅ Better performance: Sequential GUID
public sealed record OrderId
{
    public Guid Value { get; }
    
    private OrderId(Guid value) => Value = value;
    
    public static OrderId New()
    {
        // Sequential GUID for better database performance
        return new OrderId(NewSequentialGuid());
    }
    
    public static OrderId Parse(string value)
    {
        if (Guid.TryParse(value, out var guid))
            return new OrderId(guid);
        
        throw new ArgumentException($"Invalid OrderId: {value}");
    }
    
    private static Guid NewSequentialGuid()
    {
        // SQL Server NEWSEQUENTIALID()-compatible
        var guidBytes = Guid.NewGuid().ToByteArray();
        var now = DateTimeOffset.UtcNow;
        
        // Make it sequential by time
        var timeBytes = BitConverter.GetBytes(now.Ticks);
        Array.Copy(timeBytes, 0, guidBytes, 10, 6);
        
        return new Guid(guidBytes);
    }
}
```

### Strategy 4: Natural Business Key

```csharp
// ✅ When business has natural identifier
public sealed record ISBN
{
    public string Value { get; }
    
    private ISBN(string value) => Value = value;
    
    public static Result<ISBN, string> Create(string isbn)
    {
        var cleaned = isbn.Replace("-", "").Replace(" ", "");
        
        if (cleaned.Length != 10 && cleaned.Length != 13)
            return Result<ISBN, string>.Failure("ISBN must be 10 or 13 digits");
        
        if (!IsValidISBN(cleaned))
            return Result<ISBN, string>.Failure("Invalid ISBN checksum");
        
        return Result<ISBN, string>.Success(new ISBN(cleaned));
    }
    
    private static bool IsValidISBN(string isbn)
    {
        // Validate ISBN checksum
        // ... implementation
        return true;
    }
}

public sealed class Book
{
    public ISBN Id { get; }  // Natural business key
    public BookTitle Title { get; }
    public Author Author { get; }
    
    private Book(ISBN isbn, BookTitle title, Author author)
    {
        Id = isbn;
        Title = title;
        Author = author;
    }
}
```

### Strategy 5: Composite Natural Key

```csharp
// ✅ Multiple values form natural identity
public sealed record FlightId
{
    public AirlineCode Airline { get; }
    public FlightNumber Number { get; }
    public DateOnly Date { get; }
    
    private FlightId(AirlineCode airline, FlightNumber number, DateOnly date)
    {
        Airline = airline;
        Number = number;
        Date = date;
    }
    
    public static FlightId Create(AirlineCode airline, FlightNumber number, DateOnly date) =>
        new FlightId(airline, number, date);
    
    // Business identifies flights by airline, number, and date
    public override string ToString() => $"{Airline.Value}{Number.Value}-{Date:yyyyMMdd}";
}

public sealed class Flight
{
    public FlightId Id { get; }
    public Airport Origin { get; }
    public Airport Destination { get; }
    public TimeOnly DepartureTime { get; }
    
    // Flight identity is composite: AA100 on 2024-01-15
}
```

### Strategy 6: Hi-Lo Algorithm

```csharp
// ✅ Optimized ID generation for batch operations
public sealed class HiLoIdGenerator
{
    private readonly IHiLoRepository _repo;
    private long _currentHi;
    private long _currentLo;
    private readonly int _maxLo = 1000;
    
    public HiLoIdGenerator(IHiLoRepository repo)
    {
        _repo = repo;
        _currentHi = -1;
        _currentLo = _maxLo;
    }
    
    public async Task<long> NextId()
    {
        if (_currentLo >= _maxLo)
        {
            _currentHi = await _repo.GetNextHi();
            _currentLo = 0;
        }
        
        _currentLo++;
        return (_currentHi * _maxLo) + _currentLo;
    }
}

public sealed record OrderId
{
    public long Value { get; }
    
    private OrderId(long value) => Value = value;
    
    public static async Task<OrderId> New(HiLoIdGenerator generator)
    {
        var id = await generator.NextId();
        return new OrderId(id);
    }
}
```

### Strategy 7: ULID (Universally Unique Lexicographically Sortable Identifier)

```csharp
// ✅ Sortable, URL-safe, timestamp-based IDs
public sealed record OrderId
{
    public Ulid Value { get; }
    
    private OrderId(Ulid value) => Value = value;
    
    public static OrderId New()
    {
        // ULID: Timestamp + randomness
        // Sortable, base32 encoded, URL-safe
        return new OrderId(Ulid.NewUlid());
    }
    
    public static Result<OrderId, string> Parse(string value)
    {
        if (Ulid.TryParse(value, out var ulid))
            return Result<OrderId, string>.Success(new OrderId(ulid));
        
        return Result<OrderId, string>.Failure($"Invalid OrderId: {value}");
    }
    
    public DateTimeOffset Timestamp => Value.Time;
    
    // Can extract timestamp from ID
    public override string ToString() => Value.ToString();  // Base32 encoded
}

// Usage
var id = OrderId.New();
// Output: 01ARZ3NDEKTSV4RRFFQ69G5FAV
// Sortable, contains timestamp, URL-safe
```

### Strategy 8: Snowflake ID (Twitter-style)

```csharp
// ✅ Distributed ID generation without coordination
public sealed class SnowflakeIdGenerator
{
    private readonly long _machineId;
    private readonly long _epoch;
    private long _sequence = 0;
    private long _lastTimestamp = -1;
    
    public SnowflakeIdGenerator(long machineId, long epoch)
    {
        _machineId = machineId;
        _epoch = epoch;
    }
    
    public long NextId()
    {
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        
        if (timestamp < _lastTimestamp)
            throw new InvalidOperationException("Clock moved backwards");
        
        if (timestamp == _lastTimestamp)
        {
            _sequence = (_sequence + 1) & 4095;  // 12 bits
            if (_sequence == 0)
            {
                // Wait for next millisecond
                while (timestamp <= _lastTimestamp)
                {
                    timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
                }
            }
        }
        else
        {
            _sequence = 0;
        }
        
        _lastTimestamp = timestamp;
        
        // 64-bit ID: 41 bits timestamp + 10 bits machine + 12 bits sequence
        return ((timestamp - _epoch) << 22) | (_machineId << 12) | _sequence;
    }
}

public sealed record OrderId
{
    public long Value { get; }
    
    private OrderId(long value) => Value = value;
    
    public static OrderId New(SnowflakeIdGenerator generator) =>
        new OrderId(generator.NextId());
    
    public DateTimeOffset ExtractTimestamp(long epoch)
    {
        var timestamp = (Value >> 22) + epoch;
        return DateTimeOffset.FromUnixTimeMilliseconds(timestamp);
    }
}
```

## Choosing the Right Strategy

```csharp
/// <summary>
/// Decision guide for identity strategy selection.
/// </summary>
public static class IdentityStrategyGuide
{
    // Use auto-increment when:
    // - Single database, no distributed system
    // - Order of creation important
    // - Performance not critical
    // - Simplicity valued
    public static int AutoIncrement() => throw new NotImplementedException();
    
    // Use random GUID when:
    // - Distributed system (no central coordination)
    // - Need ID before database save
    // - Security important (not guessable)
    // - Database performance not critical
    public static Guid RandomGuid() => Guid.NewGuid();
    
    // Use sequential GUID when:
    // - SQL Server (clustered index performance)
    // - Need GUID benefits
    // - Database performance important
    // - Order by creation time useful
    public static Guid SequentialGuid() => throw new NotImplementedException();
    
    // Use natural business key when:
    // - Business has established identifier
    // - External systems use this ID
    // - Human-readable important
    // - Stable over time
    public static string NaturalKey() => throw new NotImplementedException();
    
    // Use ULID when:
    // - Need sortability
    // - URL-safe string important
    // - Want timestamp extraction
    // - NoSQL database
    public static Ulid ULID() => Ulid.NewUlid();
    
    // Use Snowflake when:
    // - Highly distributed system
    // - Need timestamp + machine ID
    // - Extremely high throughput
    // - 64-bit integer preferred
    public static long Snowflake() => throw new NotImplementedException();
}
```

## Comparison Table

| Strategy | Pros | Cons | Use When |
|----------|------|------|----------|
| **Auto-increment** | Simple, sequential, small | Central coordination, predictable | Single database |
| **Random GUID** | Distributed, unguessable | Large (16 bytes), not sortable, DB performance | Distributed systems |
| **Sequential GUID** | Distributed, sortable, SQL Server optimized | Complex generation | SQL Server with GUIDs |
| **Natural key** | Business-meaningful, readable | May change, complex validation | Established business ID |
| **Composite key** | Exact business semantics | Complex queries, large | Multiple values identify |
| **Hi-Lo** | Sequential, batch-friendly | Needs coordination | Batch operations |
| **ULID** | Sortable, URL-safe, timestamp | Relatively new standard | Modern distributed systems |
| **Snowflake** | Distributed, timestamp, high throughput | Clock dependency, complex | Twitter-scale systems |

## Why It's a Problem

1. **Conflicts**: Auto-increment fails in distributed systems
2. **Performance**: Random GUIDs cause index fragmentation
3. **Leaking information**: Sequential IDs reveal record counts
4. **Integration pain**: Wrong ID type for external systems

## Symptoms

- Merge conflicts in distributed systems
- Slow database inserts with GUIDs
- Need to save entity before using its ID
- External systems can't use your IDs

## Benefits

- **Right tool for job**: Match strategy to requirements
- **Performance**: Choose appropriate for database
- **Distribution**: Work in distributed systems
- **Integration**: IDs work with external systems

## See Also

- [Strongly Typed IDs](./strongly-typed-ids.md) — wrapping IDs in types
- [Entities vs Value Objects](./entities-vs-value-objects.md) — identity vs equality
- [Smart Constructors](./smart-constructors.md) — validated ID creation
- [Aggregate Roots](./aggregate-roots.md) — entity boundaries
